Push(value) command pushes constant to the stack
Push(memory) pushes value from memory cell with given id to the stack
Add()/Mul()/etc - works on stack top operands, result is pushed back to the stack
Greater()/Less()/Eq - the same, pushes back boolean
Goto() pops address and value from stack and goes to address if value not zero

Memory is limited array of cells, every cell is 4 bytes, there are 256 cells


Now the table:
PushValI   0x01   1 int ()
PushValF   0x02   1 double ()
PushValS   0x03   
PushMem    0x05   1 addr (1 byte)

PopMem     0x15   1 addr (1 byte)
SeekMem    0x16   1 addr (1 byte)       ; same as PopMem, bot w/o actual popping

Integer functions:
AddI       0x30   i,i->i
SubI       0x31   i,i->i
MulI       0x32   i,i->i
DivI       0x33   i,i->i
InvertI    0x34   i  ->i                ; inverts top of the stack

Float functions:
AddF       0x40   f,f->f
SubF       0x41   f,f->f
MulF       0x42   f,f->f
DivF       0x43   f,f->f
InvertF    0x44   f  ->f                ; inverts top of the stack

EqualsI    0x50   i,i->b
!EqualsI   0x51   i,i->b

GreaterI   0x52   i,i->b
LessI      0x53   i,i->b
GreaterEqI 0x54   i,i->b
LessEqI    0x55   i,i->b

EqualsF    0x60   f,f->b
!EqualsF   0x61   f,f->b

GreaterF   0x62   f,f->b
LessF      0x63   f,f->b
GreaterEqF 0x64   f,f->b
LessEqF    0x65   f,f->b

Not        0x6A   b  ->b
And        0x6B   b,b->b
Or         0x6C   b,b->b

itof	   0x70   i  ->f          ; cast int to float
ftoi	   0x71   f  ->i          ; cast float to int, truncates

itos       0x72   i  ->s
stoi       0x73   s  ->i

ftos       0x74   f  ->s
stof       0x75   s  ->f

If         0x80                   ; pops a1, a2, if(a1) Goto a2
Goto       0x81                   ;  



And just for now:
Exit       0xA1                   ; Exits program, should be at the end 
Read       0xA2                   ; Pushes read value
WriteI     0xA3                   ; does NOT pops value
WriteF     0xA4                  
WriteB     0xA5                 
WriteS     0xA6                  